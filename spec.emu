<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<pre class="metadata">
title: Discard Bindings
status: proposal
stage: 1
contributors: Ron Buckton, Ecma International
</pre>

<emu-biblio href="node_modules/@tc39/ecma262-biblio/biblio.json"></emu-biblio>

<emu-intro id="intro">
  <h1>Introduction</h1>
  <p>See <a href="https://github.com/tc39/proposal-discard-binding">the proposal repository</a> for background material and discussion.</p>
</emu-intro>

<emu-clause id="sec-syntax-directed-operations" number="8">
  <h1>Syntax-Directed Operations</h1>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis" number="2">
    <h1>Scope Analysis</h1>

    <emu-clause id="sec-static-semantics-boundnames" type="sdo">
      <h1>Static Semantics: BoundNames ( ): a List of Strings</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* is used within this specification as a synthetic name for a module's default export when it does not have another name. An entry in the module's [[Environment]] is created with that name and holds the corresponding value, and resolving the export named *"default"* by calling <emu-xref href="#sec-resolveexport" title></emu-xref> for the module will return a ResolvedBinding Record whose [[BindingName]] is *"\*default\*"*, which will then resolve in the module's [[Environment]] to the above-mentioned value. This is done only for ease of specification, so that anonymous default exports can be resolved like any other export. This *"\*default\*"* string is never accessible to ECMAScript code or to the module linking algorithm.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is the StringValue of |Identifier|.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. Return ¬´ *"yield"* ¬ª.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. Return ¬´ *"await"* ¬ª.
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingList|.
      </emu-alg>
      <emu-grammar>
        UsingDeclaration :
          `using` BindingList `;`

        AwaitUsingDeclaration :
          CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingList|.
      </emu-alg>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |BindingList|.
        1. Let _names2_ be the BoundNames of |LexicalBinding|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <ins class="block">
      <emu-grammar>LexicalBinding : `void` Initializer</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      </ins>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |VariableDeclarationList|.
        1. Let _names2_ be BoundNames of |VariableDeclaration|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingPropertyList|.
        1. Let _names2_ be BoundNames of |BindingRestProperty|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingRestElement|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingElementList|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingElementList|.
        1. Let _names2_ be BoundNames of |BindingRestElement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingPropertyList|.
        1. Let _names2_ be BoundNames of |BindingProperty|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingElementList|.
        1. Let _names2_ be BoundNames of |BindingElisionElement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. Return BoundNames of |BindingElement|.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingElement|.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <ins class="block">
      <emu-grammar>BindingElement : `void`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      </ins>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ForBinding|.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return ¬´ *"\*default\*"* ¬ª.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |FormalParameterList|.
        1. Let _names2_ be BoundNames of |FunctionRestParameter|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |FormalParameterList|.
        1. Let _names2_ be BoundNames of |FormalParameter|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return the BoundNames of _formals_.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return ¬´ *"\*default\*"* ¬ª.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return ¬´ *"\*default\*"* ¬ª.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Return ¬´ *"\*default\*"* ¬ª.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return ¬´ *"\*default\*"* ¬ª.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. Return the BoundNames of _head_.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ImportClause|.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.
        1. Let _names2_ be the BoundNames of |NameSpaceImport|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.
        1. Let _names2_ be the BoundNames of |NamedImports|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportsList|.
        1. Let _names2_ be the BoundNames of |ImportSpecifier|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ImportedBinding|.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |VariableStatement|.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |Declaration|.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. Let _declarationNames_ be the BoundNames of |HoistableDeclaration|.
        1. If _declarationNames_ does not include the element *"\*default\*"*, append *"\*default\*"* to _declarationNames_.
        1. Return _declarationNames_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. Let _declarationNames_ be the BoundNames of |ClassDeclaration|.
        1. If _declarationNames_ does not include the element *"\*default\*"*, append *"\*default\*"* to _declarationNames_.
        1. Return _declarationNames_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. Return ¬´ *"\*default\*"* ¬ª.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous" number="6">
    <h1>Miscellaneous</h1>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" otype="sdo" number="3">
      <h1>
        Runtime Semantics: IteratorBindingInitialization (
          _iteratorRecord_: an Iterator Record,
          _environment_: an Environment Record or *undefined*,
        ): either a normal completion containing ~unused~ or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. Return ~unused~.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. If |Elision| is present, then
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. If |Elision| is present, then
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |BindingElisionElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
        1. Let _v_ be *undefined*.
        1. If _iteratorRecord_.[[Done]] is *false*, then
          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
          1. If _next_ is not ~done~, then
            1. Set _v_ to _next_.
        1. If |Initializer| is present and _v_ is *undefined*, then
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _defaultValue_ be ? Evaluation of |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
        1. Return ? InitializeReferencedBinding(_lhs_, _v_).
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. If _iteratorRecord_.[[Done]] is *false*, then
          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
          1. If _next_ is not ~done~, then
            1. Set _v_ to _next_.
        1. If |Initializer| is present and _v_ is *undefined*, then
          1. Let _defaultValue_ be ? Evaluation of |Initializer|.
          1. Set _v_ to ? GetValue(_defaultValue_).
        1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.
      </emu-alg>
      <ins class="block">
      <emu-grammar>BindingElement : `void`</emu-grammar>
      <emu-alg>
        1. If _iteratorRecord_.[[Done]] is *false*, then
          1. Perform ? IteratorStepValue(_iteratorRecord_).
        1. Return ~unused~.
      </emu-alg>
      </ins>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. Let _next_ be ~done~.
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).
          1. If _next_ is ~done~, then
            1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).
            1. Return ? InitializeReferencedBinding(_lhs_, _A_).
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(ùîΩ(_n_)), _next_).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. Let _next_ be ~done~.
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).
          1. If _next_ is ~done~, then
            1. Return ? BindingInitialization of |BindingPattern| with arguments _A_ and _environment_.
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(ùîΩ(_n_)), _next_).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return ~unused~.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |FunctionRestParameter| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |FormalParameter| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
        1. If _next_ is not ~done~, then
          1. Set _v_ to _next_.
        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
        1. If _next_ is not ~done~, then
          1. Set _v_ to _next_.
        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.
      </emu-alg>
    </emu-clause>

  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-primary-expression" number="2">
    <h1>Primary Expression</h1>

    <emu-clause id="sec-array-initializer" number="4">
      <h1>Array Initializer</h1>
      <emu-note>
        <p>An |ArrayLiteral| is an expression describing the initialization of an Array, using a list, of zero or more expressions each of which represents an array element, enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initializer is evaluated.</p>
      </emu-note>
      <p>Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an |AssignmentExpression| (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ArrayLiteral[Yield, Await] :
          `[` Elision? `]`
          `[` ElementList[?Yield, ?Await] `]`
          `[` ElementList[?Yield, ?Await] `,` Elision? `]`

        ElementList[Yield, Await] :
          Elision? AssignmentExpression[+In, ?Yield, ?Await]</del>
          Elision? SpreadElement[?Yield, ?Await]
          <ins>CoverDiscardElement</ins>
          ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]
          <ins>ElementList[?Yield, ?Await] `,` CoverDiscardElement</ins>

        Elision :
          `,`
          Elision `,`

        SpreadElement[Yield, Await] :
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        <ins>
        CoverDiscardElement :
          Elision? `void`
        </ins>
      </emu-grammar>
      <ins class="block">
      <emu-note>
        <p>In certain contexts, |ArrayLiteral| is used as a cover grammar for a more restricted secondary grammar. The |CoverDiscardElement| production is necessary to fully cover these secondary grammars. However, use of this production results in an early Syntax Error in normal contexts where an actual |ArrayLiteral| is expected.</p>
      </emu-note>

      <emu-clause id="sec-array-initializer-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <p>In addition to describing an actual array initializer the |ArrayLiteral| productions are also used as a cover grammar for |ArrayAssignmentPattern| and may be recognized as part of a |CoverParenthesizedExpressionAndArrowParameterList|. When |ArrayLiteral| appears in a context where |ArrayAssignmentPattern| is required the following Early Error rules are <b>not</b> applied. In addition, they are not applied when initially parsing a |CoverParenthesizedExpressionAndArrowParameterList| or |CoverCallExpressionAndAsyncArrowHead|.</p>
        <emu-grammar>CoverDiscardElement : Elision? `void`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text is matched by this produciton.
          </li>
        </ul>
        <emu-note>
          <p>This production exists so that |ArrayLiteral| can serve as a cover grammar for |ArrayAssignmentPattern|. It cannot occur in an actual array initializer.</p>
        </emu-note>
      </emu-clause>
      </ins>

    </emu-clause>

    <emu-clause id="sec-object-initializer">
      <h1>Object Initializer</h1>
      <emu-note>
        <p>An object initializer is an expression describing the initialization of an Object, written in a form resembling a literal. It is a list of zero or more pairs of property keys and associated values, enclosed in curly brackets. The values need not be literals; they are evaluated each time the object initializer is evaluated.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ObjectLiteral[Yield, Await] :
          `{` `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`

        PropertyDefinitionList[Yield, Await] :
          PropertyDefinition[?Yield, ?Await]
          PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]

        PropertyDefinition[Yield, Await] :
          IdentifierReference[?Yield, ?Await]
          CoverInitializedName[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
          <ins>CoverDiscardProperty[?Yield, ?Await]</ins>
          MethodDefinition[?Yield, ?Await]
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        PropertyName[Yield, Await] :
          LiteralPropertyName
          ComputedPropertyName[?Yield, ?Await]

        LiteralPropertyName :
          IdentifierName
          StringLiteral
          NumericLiteral

        ComputedPropertyName[Yield, Await] :
          `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

        CoverInitializedName[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

        <ins>
        CoverDiscardProperty[Yield, Await] :
          PropertyName[?Yield, ?Await] `:` `void`
        </ins>

        Initializer[In, Yield, Await] :
          `=` AssignmentExpression[?In, ?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>|MethodDefinition| is defined in <emu-xref href="#sec-method-definitions"></emu-xref>.</p>
      </emu-note>
      <emu-note>
        <p>In certain contexts, |ObjectLiteral| is used as a cover grammar for a more restricted secondary grammar. The |CoverInitializedName| <del>production is</del><ins> and |CoverDiscardProperty| productions are</ins> necessary to fully cover these secondary grammars. However, use of <del>this production</del><ins>these productions</ins> results in an early Syntax Error in normal contexts where an actual |ObjectLiteral| is expected.</p>
      </emu-note>

      <emu-clause id="sec-object-initializer-static-semantics-early-errors" oldids="sec-__proto__-property-names-in-object-initializers">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if HasDirectSuper of |MethodDefinition| is *true*.
          </li>
          <li>
            It is a Syntax Error if the PrivateBoundIdentifiers of |MethodDefinition| is not empty.
          </li>
        </ul>
        <p>In addition to describing an actual object initializer the |ObjectLiteral| productions are also used as a cover grammar for |ObjectAssignmentPattern| and may be recognized as part of a |CoverParenthesizedExpressionAndArrowParameterList|. When |ObjectLiteral| appears in a context where |ObjectAssignmentPattern| is required the following Early Error rules are <b>not</b> applied. In addition, they are not applied when initially parsing a |CoverParenthesizedExpressionAndArrowParameterList| or |CoverCallExpressionAndAsyncArrowHead|.</p>
        <emu-grammar>PropertyDefinition : CoverInitializedName</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text is matched by this production.
          </li>
        </ul>
        <emu-note>
          <p>This production exists so that |ObjectLiteral| can serve as a cover grammar for |ObjectAssignmentPattern|. It cannot occur in an actual object initializer.</p>
        </emu-note>
        <ins class="block">
        <emu-grammar>PropertyDefinition : CoverDiscardProperty</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text is matched by this production.
          </li>
        </ul>
        <emu-note>
          <p>This production exists so that |ObjectLiteral| can serve as a cover grammar for |ObjectAssignmentPattern|. It cannot occur in an actual object initializer.</p>
        </emu-note>
        </ins>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the PropertyNameList of |PropertyDefinitionList| contains any duplicate entries for *"__proto__"* and at least two of those entries were obtained from productions of the form <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>. This rule is not applied if this |ObjectLiteral| is contained within a |Script| that is being parsed for JSON.parse (see step <emu-xref href="#step-json-parse-parse"></emu-xref> of <emu-xref href="#sec-json.parse">JSON.parse</emu-xref>).
          </li>
        </ul>
        <emu-note>
          <p>The List returned by PropertyNameList does not include property names defined using a |ComputedPropertyName|.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget
        ImportMeta

      NewTarget :
        `new` `.` `target`

      ImportMeta :
        `import` `.` `meta`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `)`

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        <ins>CoverDiscardArgument</ins>
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]
        <ins>ArgumentList[?Yield, ?Await] `,` CoverDiscardArgument</ins>

      OptionalExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

      OptionalChain[Yield, Await] :
        `?.` Arguments[?Yield, ?Await]
        `?.` `[` Expression[+In, ?Yield, ?Await] `]`
        `?.` IdentifierName
        `?.` TemplateLiteral[?Yield, ?Await, +Tagged]
        `?.` PrivateIdentifier
        OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
        OptionalChain[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        OptionalChain[?Yield, ?Await] `.` IdentifierName
        OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        OptionalChain[?Yield, ?Await] `.` PrivateIdentifier

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await]
    </emu-grammar>

    <ins class="block">
      <emu-note>
        <p>In certain contexts, |Arguments| is used as a cover grammar for a more restricted secondary grammar. The |CoverDiscardArgument| production is necessary to fully cover these secondary grammars. However, use of this production results in an early Syntax Error in normal contexts where an actual |Arguments| is expected.</p>
      </emu-note>
      <emu-note>
        <p>DRAFT NOTE: The above changes are only applied when considering how this proposal interacts with the <a href="https://github.com/tc39/proposal-extractors">Extractors</a> proposal.</p>
      </emu-note>

    <emu-clause id="sec-array-initializer-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <p>In addition to describing an actual arguments list the |Arguments| productions are also used as a cover grammar for |ExtractorAssignmentPattern| and may be recognized as part of a |CoverParenthesizedExpressionAndArrowParameterList|. When |Arguments| appears in a context where |ExtractorAssignmentPattern| is required the following Early Error rules are <b>not</b> applied. In addition, they are not applied when initially parsing a |CoverParenthesizedExpressionAndArrowParameterList| or |CoverCallExpressionAndAsyncArrowHead|.</p>
      <emu-grammar>CoverDiscardArgument : Elision? `void`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if any source text is matched by this produciton.
        </li>
      </ul>
      <emu-note>
        <p>This production exists so that |Arguments| can serve as a cover grammar for |ExtractorAssignmentPattern|. It cannot occur in an actual arguments list.</p>
      </emu-note>
      <emu-note>
        <p>DRAFT NOTE: The above changes are only applied when considering how this proposal interacts with the <a href="https://github.com/tc39/proposal-extractors">Extractors</a> proposal.</p>
      </emu-note>
      </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-assignment-operators" number="15">
    <h1>Assignment Operators</h1>

    <emu-clause id="sec-destructuring-assignment" number="5">
      <h1>Destructuring Assignment</h1>
      <h2>Supplemental Syntax</h2>
      <p>
        In certain circumstances when processing an instance of the production<br>
        <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar><br>
        the interpretation of |LeftHandSideExpression| is refined using the following grammar:
      </p>
      <emu-grammar type="definition">
        AssignmentPattern[Yield, Await] :
          ObjectAssignmentPattern[?Yield, ?Await]
          ArrayAssignmentPattern[?Yield, ?Await]

        ObjectAssignmentPattern[Yield, Await] :
          `{` `}`
          `{` AssignmentRestProperty[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

        ArrayAssignmentPattern[Yield, Await] :
          `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
          `[` AssignmentElementList[?Yield, ?Await] `]`
          `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

        AssignmentRestProperty[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        AssignmentPropertyList[Yield, Await] :
          AssignmentProperty[?Yield, ?Await]
          AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

        AssignmentElementList[Yield, Await] :
          AssignmentElisionElement[?Yield, ?Await]
          AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

        AssignmentElisionElement[Yield, Await] :
          Elision? AssignmentElement[?Yield, ?Await]

        AssignmentProperty[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

        AssignmentElement[Yield, Await] :
          DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          <ins>`void`</ins>

        AssignmentRestElement[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        DestructuringAssignmentTarget[Yield, Await] :
          LeftHandSideExpression[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-iteratordestructuringassignmentevaluation" type="sdo" number="5">
        <h1>
          Runtime Semantics: IteratorDestructuringAssignmentEvaluation (
            _iteratorRecord_: an Iterator Record,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElementList : AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>AssignmentElementList : AssignmentElementList `,` AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_.
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : AssignmentElement</emu-grammar>
        <emu-alg>
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : Elision AssignmentElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.
          1. Let _value_ be *undefined*.
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is not ~done~, then
              1. Set _value_ to _next_.
          1. If |Initializer| is present and _value_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then
              1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Let _v_ be ? GetValue(_defaultValue_).
          1. Else,
            1. Let _v_ be _value_.
          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then
            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
            1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.
          1. Return ? PutValue(_lref_, _v_).
        </emu-alg>
        <emu-note>
          <p>Left to right evaluation order is maintained by evaluating a |DestructuringAssignmentTarget| that is not a destructuring pattern prior to accessing the iterator or evaluating the |Initializer|.</p>
        </emu-note>
        <ins class="block">
        <emu-grammar>AssignmentElement : `void`</emu-grammar>
        <emu-alg>
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Perform ? IteratorStepValue(_iteratorRecord_).
          1. Return ~unused~.
        </emu-alg>
        </ins>
        <emu-grammar>AssignmentRestElement : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _n_ be 0.
          1. Repeat, while _iteratorRecord_.[[Done]] is *false*,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is not ~done~, then
              1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(ùîΩ(_n_)), _next_).
              1. Set _n_ to _n_ + 1.
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Return ? PutValue(_lref_, _A_).
          1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
          1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyeddestructuringassignmentevaluation" type="sdo" number="6">
        <h1>
          Runtime Semantics: KeyedDestructuringAssignmentEvaluation (
            _value_: an ECMAScript language value,
            _propertyName_: a property key,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then
              1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Let _rhsValue_ be ? GetValue(_defaultValue_).
          1. Else,
            1. Let _rhsValue_ be _v_.
          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then
            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
            1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.
          1. Return ? PutValue(_lref_, _rhsValue_).
        </emu-alg>
        <ins class="block">
        <emu-grammar>AssignmentElement : `void`</emu-grammar>
        <emu-alg>
          1. Perform ? GetV(_value_, _propertyName_).
          1. Return ~unused~.
        </emu-alg>
        </ins>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations" number="14">
  <h1>ECMAScript Language: Statements and Declarations</h1>
  <emu-clause id="sec-declarations-and-the-variable-statement" number="3">
    <h1>Declarations and the Variable Statement</h1>
    <emu-clause id="sec-let-const-using-and-await-using-declarations" oldids="sec-let-and-const-declarations" number="1">
      <h1>Let, Const, Using, and Await Using Declarations</h1>

      <h2>Syntax</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await, +Pattern] `;`
          UsingDeclaration[?In, ?Yield, ?Await]
          [+Await] AwaitUsingDeclaration[?In, ?Yield]

        LetOrConst :
          `let`
          `const`

        UsingDeclaration[In, Yield, Await] :
          `using` [no LineTerminator here] BindingList[?In, ?Yield, ?Await, ~Pattern] `;`

        AwaitUsingDeclaration[In, Yield] :
          CoverAwaitExpressionAndAwaitUsingDeclarationHead[?Yield] [no LineTerminator here] BindingList[?In, ?Yield, +Await, ~Pattern] `;`

        BindingList[In, Yield, Await, Pattern] :
          LexicalBinding[?In, ?Yield, ?Await, ?Pattern]
          BindingList[?In, ?Yield, ?Await, ?Pattern] `,` LexicalBinding[?In, ?Yield, ?Await, ?Pattern]

        LexicalBinding[In, Yield, Await, Pattern] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          [+Pattern] BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
          <ins>[~Pattern] `void` Initializer[?In, ?Yield, ?Await]</ins>
      </emu-grammar>

      <emu-clause id="sec-let-const-using-and-await-using-declarations-runtime-semantics-bindingevaluation" type="sdo" number="2">
        <h1>
          Runtime Semantics: BindingEvaluation (
            _hint_: one of ~normal~, ~sync-dispose~, or ~async-dispose~,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Perform ? BindingEvaluation of |BindingList| with argument _hint_.
          1. Return ? BindingEvaluation of |LexicalBinding| with argument _hint_.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Assert: _hint_ is ~normal~.
          1. Let _lhs_ be ! ResolveBinding(StringValue of |BindingIdentifier|).
          1. Perform ! InitializeReferencedBinding(_lhs_, *undefined*, ~normal~).
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>A static semantics rule ensures that this form of |LexicalBinding| never occurs in a `const`, `using`, or `await using` declaration.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ! ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be ? Evaluation of |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Perform ? InitializeReferencedBinding(_lhs_, _value_, _hint_).
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Assert: _hint_ is ~normal~.
          1. Let _rhs_ be ? Evaluation of |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.
        </emu-alg>
        <ins class="block">
          <emu-grammar>LexicalBinding : `void` Initializer</emu-grammar>
          <emu-alg>
            1. Assert: _hint_ is not ~normal~.
            1. Let _env_ be the running execution context's LexicalEnvironment.
            1. Assert: _env_ is an Environment Record.
            1. Let _rhs_ be ? Evaluation of |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
            1. Perform ? AddDisposableResource(_env_.[[DisposeCapability]], _value_, _hint_).
            1. Return ~unused~.
          </emu-alg>
          </ins>
        </emu-clause>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns" number="3">
      <h1>Destructuring Binding Patterns</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BindingPattern[Yield, Await] :
          ObjectBindingPattern[?Yield, ?Await]
          ArrayBindingPattern[?Yield, ?Await]

        ObjectBindingPattern[Yield, Await] :
          `{` `}`
          `{` BindingRestProperty[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

        ArrayBindingPattern[Yield, Await] :
          `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
          `[` BindingElementList[?Yield, ?Await] `]`
          `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

        BindingRestProperty[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]

        BindingPropertyList[Yield, Await] :
          BindingProperty[?Yield, ?Await]
          BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

        BindingElementList[Yield, Await] :
          BindingElisionElement[?Yield, ?Await]
          BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

        BindingElisionElement[Yield, Await] :
          Elision? BindingElement[?Yield, ?Await]

        BindingProperty[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

        BindingElement[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          <ins>`void`</ins>

        SingleNameBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        BindingRestElement[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]
          `...` BindingPattern[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo" number="3">
        <h1>
          Runtime Semantics: KeyedBindingInitialization (
            _value_: an ECMAScript language value,
            _environment_: an Environment Record or *undefined*,
            _propertyName_: a property key,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. Let _defaultValue_ be ? Evaluation of |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.
        </emu-alg>
        <ins class="block">
        <emu-grammar>BindingElement : `void`</emu-grammar>
        <emu-alg>
          1. Perform ? GetV(_value_, _propertyName_).
          1. Return ~unused~.
        </emu-alg>
        </ins>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
          1. Return ? InitializeReferencedBinding(_lhs_, _v_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
